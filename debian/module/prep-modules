#! /bin/sh
#
# Prepares to build kernel modules.  This script figures out and munges
# version strings.  The goal is:
#
#  * Set the package name to openafs-modules-$(KVERS) where $(KVERS) is the
#    major kernel revision plus the debian subrevision and whatever
#    architecture string is appropriate if building against the stock Debian
#    kernels.  $(KVERS) should be identical to the version component contained
#    in the Debian kernel package names (in other words, the ABI version, not
#    the package version)..
#
#  * Make the package recommend linux-image-$(KVERS) as appropriate for the
#    kernel version that we're building against.  Use recommend rather than
#    depends since the user may have built their own kernel outside of the
#    Debian package infrastructure.
#
#  * Save the version number of the binary package in debian/VERSION for later
#    use by dh_gencontrol.  This will be the version number of the source
#    package followed by a + and the version number of the kernel package that
#    we're building against.  If the kernel package version contains an epoch,
#    try to hack our way into doing the right thing by using that epoch number
#    as our own.  This isn't quite the right thing, but seems reasonably good.
#
# This script generates debian/control from debian/control.module using sed.
# Unfortunately, substvars cannot be used since the name of the package is
# modified and substvars happens too late.  It also outputs debian/VERSION,
# containing the version of the binary package.

set -e

if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <kernel-source-location>" >&2
    exit 1
fi

# We can get the kernel version from one of three places.  If KVERS and KDREV
# are both already set in the environment (which will be the case when invoked
# by make-kpkg or module-assistant), use them.  Otherwise, if we have a kernel
# source directory that contains debian/changelog (generated by make-kpkg),
# parse that file to find the version information.  Finally, if neither works,
# extract the kernel version from the kernel headers, append INT_SUBARCH to
# that version if it's available, and assume a kernel package revision of -0
# if none is provided.
#
# Set the variables $spl_kvers, which will hold the revision of the kernel,
# and $spl_kdrev, which will hold the version of the kernel package that we're
# building against.

changelog="$1/debian/changelog"
if [ -n "$KVERS" ] && [ -n "$KDREV" ]; then
    spl_kvers="${KVERS}${INT_SUBARCH}"
    spl_kdrev="${KDREV}"
elif [ ! -f "$changelog" ] ; then
    if [ -n "$KVERS" ] ; then
        spl_kvers="$KVERS"
    else
        spl_kvers=`perl debian/kernel-version "$1"`
    fi
    if [ -z "$KDREV" ] ; then
        spl_kdrev="${spl_kvers}-0"
    else
        spl_kvers="${spl_kvers}${INT_SUBARCH}"
        spl_kdrev="${KDREV}"
    fi
else
    if [ -n "$KVERS" ] ; then
        spl_kvers="$KVERS"
    else
        spl_kvers=`head -1 "$changelog" \
            | sed -e 's/.*source-\([^ ]*\) (\([^)]*\)).*/\1/'`
    fi
    spl_kdrev=`head -1 "$changelog" \
        | sed -e 's/.*source-\([^ ]*\) (\([^)]*\)).*/\2/'`
fi

# Generate the control file from the template.

sed -e "s/=KVERS/${spl_kvers}/g" debian/control.in > debian/control

# Now, calcuate the binary package version.  Extract the epoch from the kernel
# package revision and add it to the beginning of the binary package version
# if present.  Then, concatenate the source version, '+', and the kernel
# package revision without the epoch.

spl_version=`head -1 debian/changelog | sed -e 's/.*(\([^)]*\)).*/\1/'`
spl_epoch=`echo ${spl_kdrev} | sed -n -e 's/^\([0-9]*\):.*/\1/p'`
spl_version="${spl_version}+`echo ${spl_kdrev} | sed -e 's/^[0-9]*://'`"
if [ -n "$spl_epoch" ] ; then
    spl_version="${spl_epoch}:${spl_version}"
fi

echo "$spl_version" > debian/VERSION
